{"ts":1349265274799,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"HOST = \"0.0.0.0\";\nPORT = process.env.C9_PORT;\n\n// when the daemon started\nvar starttime = (new Date()).getTime();\n\nvar mem = process.memoryUsage();\n// every 10 seconds poll for the memory.\nsetInterval(function () {\n  mem = process.memoryUsage();\n}, 10*1000);\n\n\nvar fu = require(\"./fu\"),\n    sys = require(\"sys\"),\n    url = require(\"url\"),\n    qs = require(\"querystring\");\n\nvar MESSAGE_BACKLOG = 200,\n    SESSION_TIMEOUT = 60 * 1000;\n\nvar channel = new function () {\n  var messages = [],\n      callbacks = [];\n\n  this.appendMessage = function (nick, type, text) {\n    var m = { nick: nick\n            , type: type // \"msg\", \"join\", \"part\"\n            , text: text\n            , timestamp: (new Date()).getTime()\n            };\n\n    switch (type) {\n      case \"msg\":\n        sys.puts(\"<\" + nick + \"> \" + text);\n        break;\n      case \"join\":\n        sys.puts(nick + \" join\");\n        break;\n      case \"part\":\n        sys.puts(nick + \" part\");\n        break;\n    }\n\n    messages.push( m );\n\n    while (callbacks.length > 0) {\n      callbacks.shift().callback([m]);\n    }\n\n    while (messages.length > MESSAGE_BACKLOG)\n      messages.shift();\n  };\n\n  this.query = function (since, callback) {\n    var matching = [];\n    for (var i = 0; i < messages.length; i++) {\n      var message = messages[i];\n      if (message.timestamp > since)\n        matching.push(message)\n    }\n\n    if (matching.length != 0) {\n      callback(matching);\n    } else {\n      callbacks.push({ timestamp: new Date(), callback: callback });\n    }\n  };\n\n  // clear old callbacks\n  // they can hang around for at most 30 seconds.\n  setInterval(function () {\n    var now = new Date();\n    while (callbacks.length > 0 && now - callbacks[0].timestamp > 30*1000) {\n      callbacks.shift().callback([]);\n    }\n  }, 3000);\n};\n\nvar sessions = {};\n\nfunction createSession (nick) {\n  if (nick.length > 50) return null;\n  if (/[^\\w_\\-^!]/.exec(nick)) return null;\n\n  for (var i in sessions) {\n    var session = sessions[i];\n    if (session && session.nick === nick) return null;\n  }\n\n  var session = { \n    nick: nick, \n    id: Math.floor(Math.random()*99999999999).toString(),\n    timestamp: new Date(),\n\n    poke: function () {\n      session.timestamp = new Date();\n    },\n\n    destroy: function () {\n      channel.appendMessage(session.nick, \"part\");\n      delete sessions[session.id];\n    }\n  };\n\n  sessions[session.id] = session;\n  return session;\n}\n\n// interval to kill off old sessions\nsetInterval(function () {\n  var now = new Date();\n  for (var id in sessions) {\n    if (!sessions.hasOwnProperty(id)) continue;\n    var session = sessions[id];\n\n    if (now - session.timestamp > SESSION_TIMEOUT) {\n      session.destroy();\n    }\n  }\n}, 1000);\n\nfu.listen(Number(process.env.PORT || PORT), HOST);\n\nfu.get(\"/\", fu.staticHandler(\"index.html\"));\nfu.get(\"/style.css\", fu.staticHandler(\"style.css\"));\nfu.get(\"/client.js\", fu.staticHandler(\"client.js\"));\nfu.get(\"/jquery-1.2.6.min.js\", fu.staticHandler(\"jquery-1.2.6.min.js\"));\n\n\nfu.get(\"/who\", function (req, res) {\n  var nicks = [];\n  for (var id in sessions) {\n    if (!sessions.hasOwnProperty(id)) continue;\n    var session = sessions[id];\n    nicks.push(session.nick);\n  }\n  res.simpleJSON(200, { nicks: nicks\n                      , rss: mem.rss\n                      });\n});\n\nfu.get(\"/join\", function (req, res) {\n  var nick = qs.parse(url.parse(req.url).query).nick;\n  if (nick == null || nick.length == 0) {\n    res.simpleJSON(400, {error: \"Bad nick.\"});\n    return;\n  }\n  var session = createSession(nick);\n  if (session == null) {\n    res.simpleJSON(400, {error: \"Nick in use\"});\n    return;\n  }\n\n  //sys.puts(\"connection: \" + nick + \"@\" + res.connection.remoteAddress);\n\n  channel.appendMessage(session.nick, \"join\");\n  res.simpleJSON(200, { id: session.id\n                      , nick: session.nick\n                      , rss: mem.rss\n                      , starttime: starttime\n                      });\n});\n\nfu.get(\"/part\", function (req, res) {\n  var id = qs.parse(url.parse(req.url).query).id;\n  var session;\n  if (id && sessions[id]) {\n    session = sessions[id];\n    session.destroy();\n  }\n  res.simpleJSON(200, { rss: mem.rss });\n});\n\nfu.get(\"/recv\", function (req, res) {\n  if (!qs.parse(url.parse(req.url).query).since) {\n    res.simpleJSON(400, { error: \"Must supply since parameter\" });\n    return;\n  }\n  var id = qs.parse(url.parse(req.url).query).id;\n  var session;\n  if (id && sessions[id]) {\n    session = sessions[id];\n    session.poke();\n  }\n\n  var since = parseInt(qs.parse(url.parse(req.url).query).since, 10);\n\n  channel.query(since, function (messages) {\n    if (session) session.poke();\n    res.simpleJSON(200, { messages: messages, rss: mem.rss });\n  });\n});\n\nfu.get(\"/send\", function (req, res) {\n  var id = qs.parse(url.parse(req.url).query).id;\n  var text = qs.parse(url.parse(req.url).query).text;\n\n  var session = sessions[id];\n  if (!session || !text) {\n    res.simpleJSON(400, { error: \"No such session id\" });\n    return;\n  }\n\n  session.poke();\n\n  channel.appendMessage(session.nick, \"msg\", text);\n  res.simpleJSON(200, { rss: mem.rss });\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":5098}]],"length":5098}
{"contributors":["detmar@ajax.org","detmar+bb@c9.io"],"silentsave":false,"ts":1349360737861,"patch":[[{"diffs":[[0,"200, { rss: mem.rss });\n});\n"],[1,"Hi there\nHello\n"]],"start1":5070,"start2":5070,"length1":28,"length2":43}]],"length":5113,"saved":false}
